import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = process.argv[2] === "production";
const analyze = process.env.ANALYZE === "true";

// ç›®æ ‡æ’ä»¶ç›®å½•
const targetPluginDir = "/Users/eric/ob/obsidian/.obsidian/plugins/chatgpt-md";

// è‡ªå®šä¹‰æ’ä»¶ï¼šåœ¨æ„å»ºåå¤åˆ¶æ–‡ä»¶
const copyPlugin = {
  name: 'copy-files',
  setup(build) {
    build.onEnd(() => {
      // ç¡®ä¿ dist ç›®å½•å­˜åœ¨
      if (!fs.existsSync("dist")) {
        fs.mkdirSync("dist", { recursive: true });
      }

      // å¤åˆ¶ manifest.json åˆ° dist/
      fs.copyFileSync("manifest.json", "dist/manifest.json");
      console.log("ğŸ“‹ å·²å¤åˆ¶ manifest.json â†’ dist/");

      // åœ¨ CI ç¯å¢ƒä¸­è·³è¿‡æœ¬åœ°å¤åˆ¶æ“ä½œ
      if (process.env.CI) {
        console.log("ğŸ”„ CI ç¯å¢ƒæ£€æµ‹åˆ°ï¼Œè·³è¿‡æœ¬åœ°æ’ä»¶ç›®å½•å¤åˆ¶");
        return;
      }

      // ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
      if (!fs.existsSync(targetPluginDir)) {
        console.log(`âš ï¸  ç›®æ ‡ç›®å½•ä¸å­˜åœ¨: ${targetPluginDir}`);
        return;
      }

      // å¤åˆ¶ dist/ é‡Œçš„æ–‡ä»¶åˆ°æ’ä»¶ç›®å½•ï¼ˆä»…æœ¬åœ°ï¼‰
      const files = fs.readdirSync("dist");
      for (const file of files) {
        const srcPath = path.join("dist", file);
        const destPath = path.join(targetPluginDir, file);
        if (fs.statSync(srcPath).isFile()) {
          fs.copyFileSync(srcPath, destPath);
          console.log(`ğŸ“‹ å·²å¤åˆ¶: dist/${file} â†’ ${targetPluginDir}`);
        }
      }
    });
  },
};

const context = await esbuild.context({
  banner: {
    js: banner,
  },
  entryPoints: ["src/main.ts"],
  bundle: true,
  external: [
    "obsidian",
    "electron",
    "@codemirror/autocomplete",
    "@codemirror/collab",
    "@codemirror/commands",
    "@codemirror/language",
    "@codemirror/lint",
    "@codemirror/search",
    "@codemirror/state",
    "@codemirror/view",
    "@lezer/common",
    "@lezer/highlight",
    "@lezer/lr",
    ...builtins,
  ],
  format: "cjs",
  target: "es2018",
  logLevel: "info",
  sourcemap: prod ? false : "inline",

  // Enhanced tree shaking and optimization options
  treeShaking: true,
  minify: prod,

  // Production-only optimizations
  ...(prod && {
    // More aggressive minification
    minifyWhitespace: true,
    minifyIdentifiers: true,
    minifySyntax: true,

    // Advanced optimization flags
    legalComments: "none", // Remove all comments to reduce size
    keepNames: false, // Allow name mangling for smaller bundles

    // Dead code elimination
    drop: ["console", "debugger"], // Remove console.log and debugger statements

    // Pure annotations for better tree shaking
    pure: ["console.log", "console.info", "console.warn", "console.debug", "console.trace"],

    // Platform-specific optimizations
    platform: "node",

    // Bundle analysis
    metafile: analyze,
  }),

  outfile: "dist/main.js",
  plugins: [copyPlugin],
});

if (prod) {
  const result = await context.rebuild();

  // Optional: Log bundle analysis info in production
  if (result.metafile) {
    console.log("ğŸ“¦ Bundle analysis:");
    console.log(`ğŸ“ Output size: ${(result.metafile.outputs["dist/main.js"]?.bytes || 0 / 1024).toFixed(2)} KB`);

    // Show largest dependencies
    const inputs = Object.entries(result.metafile.inputs)
      .map(([path, data]) => ({ path, bytes: data.bytes }))
      .sort((a, b) => b.bytes - a.bytes)
      .slice(0, 10);

    console.log("ğŸ” Largest source files:");
    inputs.forEach(({ path, bytes }) => {
      console.log(`  ${path}: ${(bytes / 1024).toFixed(2)} KB`);
    });
  }

  process.exit(0);
} else {
  console.log("ğŸ‘€ ç›‘å¬æ¨¡å¼å¯åŠ¨ä¸­...");
  await context.watch();
}
